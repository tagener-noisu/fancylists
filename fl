#!/usr/bin/env ruby
require 'fileutils'
require 'getoptlong'

VERSION = "0.3"
STORAGE = "#{ENV["HOME"]}.fl"

class File
    def File.lock(file)
        return if !block_given?
        path = File.expand_path(file).split("/")
        f = path.pop
        path = path.join("/")
        Dir.chdir(path) {
            lock = f + ".lock"
            sleep(0.1) while (File.exist?(lock))    # wait for unlock
            FileUtils.touch(lock)                   # lock
            yield                                   # execute
            FileUtils.rm(lock)                      # unlock
        }
    end
end

def append(list)
	file = File.open(get_path(list), "a")
	while (!$stdin.eof?)
		file.print($stdin.gets)
	end
	file.close
end

def clear(list)
	file = get_path(list)
	if (File.exist?(file))
		File.delete(file)
	end
end

def list_contents(list)
	file = get_path(list)
	if (File.exist?(file))
		f = File.open(file, "r")
		f.each_line { |l|
			$stdout.print(l)
		}
	end
end

def print_lists
	Dir.foreach(STORAGE) { |f|
		if (!f.match(/^\./) && !f.match(/\.lock$/)) # skip dot files and locks
			puts(f)
		end
	}
end

def get_path(list)
	return File.join(STORAGE, list)
end

def print_usage
	$stderr.puts <<-EOF
fancylists v.#{VERSION}

Usage:
print available non-empty lists: fl
print contents of the list:      fl listname
operations on the list:          fl listname [option] ...

Options:
    -h, --help      print this usage
    -a, --append    append lines from the standard input to the list
    -c, --clear     clear the list

Operations executed in the order of appearance
EOF
end

def init
	Dir.mkdir(STORAGE) if !Dir.exist?(STORAGE)
end

def driver
	init

	list_name = nil
	case (ARGV.length)
	when 0
		print_lists
		return
	when 1
		if (!ARGV[0].match(/^-/))
			list_contents(ARGV.shift)
			return
		else
			print_usage
			return
		end
	else
		list_name = ARGV.shift
	end

	operations = []
	GetoptLong.new(
		['--append', '-a', GetoptLong::NO_ARGUMENT],
		['--clear', '-c', GetoptLong::NO_ARGUMENT]
	).each { |opt, arg|
		case (opt)
		when "--append"
			operations << :append
		when "--clear"
			operations << :clear
		end
	}

	if (ARGV.length != 0)
		print_usage
		exit
	end

	File.lock(get_path(list_name)) {
		operations.each { |op|
			case (op)
			when :append
				append(list_name)
			when :clear
				clear(list_name)
			end
		}
	}
end

begin
	driver
rescue GetoptLong::InvalidOption
	print_usage
rescue => e
	$stderr.puts(e.message)
end
